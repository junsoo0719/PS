#include <iostream>
#include <string>
#include <stack>
using namespace std;

int t;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	
	/*
	문자열을 str변수에 먼저 입력 받고 문자열의 크기만큼 한 문자씩 순회하는 방식으로
	코드를 짜보았다.
	*/
	cin >> t;
	while (t--)
	{
		string str;
		cin >> str;
		stack<string> st;
		for (size_t i = 0; i < str.size(); i++)
		{ 
			/*
			str.size()함수의 리턴 타입이 size_t이기 때문에 변수i의 타입도
			int 대신 size_t 타입으로 선언했다.
			닫는 태그가 여는 태그보다 먼저 나오는 경우는 없으므로 여는 태그에 대해
			처리해주는 else문을 먼저 보자.
			*/
			if (str[i] == '<')
			{
				/*
				idx변수는 '<'다음의 태그에 해당하는 문자열을 탐색하기 위해 
				i+1로 초기화 한 인덱스 변수이고 tmp변수는 태그에 해당하는
				문자열을 저장하여 스택에 push하거나 스택의 top과 비교하기 위해
				""공백으로 초기화 했다.
				*/
				size_t idx = i + 1;
				string tmp = "";
				if (str[idx] == '/')
				{
					/*
					닫는 태그에 해당하는 '/'를 만난다면 이후의 문자열을 탐색하기
					위해 idx를 1 증가시킨다.
					*/
					idx++;
					while (idx < str.size() && str[idx] != '>')
					{ 
						/*
						이 부분은 앞서 설명한 else 부분과 같기 때문에 설명은
						생략한다.
						*/
						tmp += str[idx++];
					}
					if (st.top() == tmp)
					{ 
						/*
						문제에 '<'는 항상 태그에서만 사용한다고 되어있고
						'<'이후에 '/'까지 나왔다면 무조건 닫는 태그일 것이다.
						또한 아직 닫히지 않은 태그가 있을 경우, 그 태그가 닫히기
						전에 다른 닫는 태그는 쓸 수 없다고 문제에 나와있다.
						"</"까지 조건문을 통해 들어왔다면 스택의 top에는 당연하게도
						현재 tmp에 저장된 닫는 태그와 짝을 이루는 여는 태그가
						저장되어 있을 것이기 때문에 사실상 이 조건문은
						안 써도 될 것 같다.
						이렇게 닫는 태그가 입력되었을 때 이 태그와 짝을 이루는
						여는 태그가 스택의 top에 저장되어 있으므로 pop을 해준다.
						아까와 마찬가지로 다음 인덱스부터 이어 탐색하기 위해
						i에 idx값을 넣는다.
						*/
						st.pop();
						i = idx;
					}
				}
				else
				{
					/*
					문제에 '<'는 항상 태그에서만 사용한다고 되어있으므로 '<'가
					입력되었다면 무조건 여는 태그일 것이다.
					idx가 문자열 크기를 넘어가지 않게끔 조건을 추가하였고
					'>'를 만나면 while문을 벗어나게 작성했다.
					*/
					while (idx < str.size() && str[idx] != '>')
					{ 
						/*
						조건을 만족한다면 '>'가 나오기 전까지의 문자를 공백이었던
						tmp에 한 문자식 추가하고 다음 인덱스를 탐색하기 위해
						idx를 1 증가시킨다.
						*/
						tmp += str[idx++];
					}
					/*
					'>'를 만나면 while문을 벗어나므로 태그에 해당하는 문자열을
					스택에 push해주고 방금까지 탐색한 idx 다음의 위치부터 이어서
					탐색하면 되므로 i에 idx값을 넣는다.
					*/
					st.push(tmp);
					i = idx;
				}	
			}
		}
		while (!st.empty())
		{
			/*
			올바른 HTML문서였다면 모든 태그들이 짝을 이루어 스택은 비어있을 것이고
			미완성 HTML문서였다면 짝을 이루지 못한 여는 태그들이 스택에 남아있을
			것이다.
			따라서 가장 마지막에 추가된 여는 태그부터 닫는 태그와 짝을 이루어주면
			되므로 스택의 top에 해당하는 문자열을 닫는 태그로 출력해준 뒤
			pop을 해주면 된다.
			*/
			cout << "</" << st.top() << ">";
			st.pop();
		}
		cout << "\n";
	}
}
/*
입력받는 문자열의 크기를 N이라고 할 때
시간 복잡도는
언뜻 보면 문자열의 크기만큼 탐색하는 for문 안에 또 while문이 있기 때문에
O(N^2)이라고 생각할 수 있다.
그러나 태그에 해당할 경우에만 while문에 들어가게 되고 while문 안에서는 i번째
인덱스 다음의 인덱스들을 탐색한 뒤에 탐색이 끝나면 i=idx를 해주기 때문에
사실상 문자열의 각 문자를 한 번씩만 순회한다.
따라서 O(N) time이다.

공간 복잡도는
입력받은 문자열을 저장하기 때문에 크기는 N이고
스택에는 태그에 해당하는 문자열만 저장하기 때문에 절대 N을 넘을 수 없다.
따라서 O(N) space이다.
*/